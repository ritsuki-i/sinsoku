<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>- 神速 -</title>
    <link rel="icon" href="./img/icon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Hina+Mincho&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            min-height: 100vh;
            margin: 0;
            background-image: url('./img/background.png'); 
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-color: #000;
            color: white;
            font-family: 'Hina Mincho', serif;
            transition: background-image 0.5s ease-in-out;
            overflow: hidden; 
        }

        #game-container {
            position: absolute;
            width: 960px; 
            height: 540px; 
            overflow: hidden;
            transform-origin: top left; 
            z-index: 1;
        }

        canvas {
            background-color: rgba(0, 0, 0, 0.8); 
            position: absolute;
            z-index: 1;
        }
        
        /* Enhanced overlay styling with backdrop blur and better visual hierarchy */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 960px;
            height: 540px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.9);
            pointer-events: none; 
            display: none;
            z-index: 2;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85) 0%, rgba(20, 20, 30, 0.9) 100%);
            backdrop-filter: blur(8px);
        }
        
        .overlay.active {
            display: flex;
            pointer-events: auto;
            animation: fadeIn 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* Styled title with decorative elements */
        .overlay .title {
            font-size: 4em;
            margin: 0 0 20px 0;
            letter-spacing: 0.3em;
            position: relative;
            padding: 0 40px;
            background: linear-gradient(180deg, #ffffff 0%, #e0e0e0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .overlay .title::before,
        .overlay .title::after {
            content: '◆';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.4em;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .overlay .title::before {
            left: 0;
        }
        
        .overlay .title::after {
            right: 0;
        }
        
        .overlay p { 
            margin: 10px 0;
            font-size: 1.2em;
        }
        
        /* Enhanced key hints with better readability */
        .overlay .key-hint {
            font-size: 0.9em;
            color: #b0b0b0;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 16px;
            border-radius: 8px;
            margin: 8px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(4px);
        }
        
        /* Modern button design with hover effects */
        .overlay button {
            font-family: 'Hina Mincho', serif;
            font-size: 1.1em;
            padding: 16px 48px;
            margin-top: 20px;
            cursor: pointer;
            border: 2px solid #00ffff;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 200, 255, 0.3) 100%);
            color: #ffffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            letter-spacing: 0.2em;
            position: relative;
            overflow: hidden;
        }
        
        .overlay button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .overlay button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .overlay button:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.4) 0%, rgba(0, 200, 255, 0.5) 100%);
            box-shadow: 0 6px 30px rgba(0, 255, 255, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            border-color: #00ffff;
        }
        
        .overlay button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 255, 255, 0.3);
        }
        
        .overlay button span {
            position: relative;
            z-index: 1;
        }
        
        #gameOverScreen .title { 
            background: linear-gradient(180deg, #ff6666 0%, #ff4444 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #gameOverScreen .title::before,
        #gameOverScreen .title::after {
            color: #ff4444;
            text-shadow: 0 0 10px #ff4444;
        }
        
        #victoryScreen .title { 
            background: linear-gradient(180deg, #66ff66 0%, #44ff44 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #victoryScreen .title::before,
        #victoryScreen .title::after {
            color: #44ff44;
            text-shadow: 0 0 10px #44ff44;
        }

        /* Enhanced ultimate button with pulsing animation */
        .game-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1.3em;
            font-family: 'Hina Mincho', serif;
            z-index: 100;
            display: none;
            border: 3px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.1em;
        }
        
        .game-button.ready {
            display: block;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.6) 0%, rgba(0, 200, 255, 0.8) 100%);
            border-color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6), 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(0, 255, 255, 0.6), 0 4px 20px rgba(0, 0, 0, 0.5);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 40px rgba(0, 255, 255, 0.8), 0 6px 25px rgba(0, 0, 0, 0.5);
            }
        }
        
        .game-button.aiming {
            display: block;
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.6) 0%, rgba(255, 100, 100, 0.8) 100%);
            border-color: #ff4444;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.6), 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .game-button:hover {
            transform: scale(1.1);
        }
        
        .game-button:active {
            transform: scale(0.95);
        }

        #rotate-device-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000;
            color: white;
            z-index: 10000;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            text-align: center;
            font-family: 'Hina Mincho', serif;
        }
        
        @media (orientation: portrait) {
            #rotate-device-overlay {
                display: flex;
            }
            #game-container {
                display: none;
            }
            .game-button {
                display: none;
            }
        }
    </style>
</head>
<body>
    
    <div id="game-container">
        <canvas id="gameCanvas" width="960" height="540"></canvas>
        
        <div id="startScreen" class="overlay active">
            <p class="title">神速</p>
            <button id="startButton"><span>始める</span></button>
            <p class="key-hint">[クリック]: 通常攻撃 (一撃で撃破)</p>
            <p class="key-hint">[Space] ゲージMAXで: 必殺・7秒間時間停止</p>
        </div>

        <div id="gameOverScreen" class="overlay">
            <p class="title">敗北</p>
            <p id="gameOverLevelDisplay" class="key-hint" style="font-size: 1.2em; margin-top: 20px;">到達レベル: 1</p>
            <button id="restartButton"><span>再挑戦</span></button>
        </div>

        <div id="victoryScreen" class="overlay">
            <p class="title">勝利</p>
            <p id="currentLevelDisplay" class="key-hint" style="font-size: 1.2em; margin-top: 20px;">現在のレベル: 1</p>
            <button id="nextLevelButton"><span>次の戦場へ</span></button>
        </div>
    </div>

    <div id="rotate-device-overlay">
        <p>画面を横向きにしてください</p>
    </div>

    <button id="ultimateButton" class="game-button"></button>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container'); 
        const ultimateButton = document.getElementById('ultimateButton');

        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;

        let gameScale = 1;

        // --- 画像ロード ---
        const playerImage = new Image();
        playerImage.src = './img/samurai.png';
        const hissatsuImage = new Image();
        hissatsuImage.src = './img/hissatsu.png';

        // --- ゲームの状態 ---
        const GAME_STATE = {
            MENU: 'menu',
            IDLE: 'idle',
            ULT_CUTSCENE: 'ult_cutscene',
            AIMING: 'aiming',
            ATTACKING: 'attacking',
            GAMEOVER: 'gameover',
            FINISHED: 'finished'
        };
        let currentState = GAME_STATE.MENU;

        // --- UI要素 ---
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const victoryScreen = document.getElementById('victoryScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const nextLevelButton = document.getElementById('nextLevelButton');
        const currentLevelDisplay = document.getElementById('currentLevelDisplay');
        const gameOverLevelDisplay = document.getElementById('gameOverLevelDisplay');

        // --- プレイヤー ---
        let player = {
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT / 2,
            size: 40,
            color: 'white',
            hp: 100,
            maxHp: 100
        };

        // --- 必殺技 / 時間停止 ---
        let ultimateGauge = 0;
        const maxUltimateGauge = 480;
        const hitStunDuration = 30;
        let cutsceneTimer = 0;
        const cutsceneDuration = 120;
        let timeStopTimer = 0;
        const timeStopDuration = 420;

        // --- 敵 ---
        let enemies = [];
        let baseEnemyCount = 5;
        const ENEMY_SIZE = 15;
        const ENEMY_COLOR = 'red';
        const ENEMY_DASH_COLOR = '#ff8888';
        const ENEMY_HIT_COLOR = 'gray';

        // --- エフェクト ---
        let attackTargets = []; 
        let slashEffects = []; 
        let timeStopEffectAlpha = 0;
        const timeStopFilterStrength = 0.5;

        // --- レベル管理 ---
        let currentLevel = 1;

        // --- 背景切り替え関数 ---
        function setBodyBackground(type) {
            if (type === 'hissatsu') {
                document.body.style.backgroundImage = "url('./img/hissatsu_background.png')";
            } else {
                document.body.style.backgroundImage = "url('./img/background.png')";
            }
        }

        // --- ゲーム初期化 (完全にリセット) ---
        function initGame() {
            currentLevel = 1;
            resetGameElements();
            player.hp = player.maxHp;
            ultimateGauge = 0;
            startScreen.classList.add('active');
            gameOverScreen.classList.remove('active');
            victoryScreen.classList.remove('active');
            currentState = GAME_STATE.MENU; 
            setBodyBackground('normal');
        }

        // --- 次のレベルへ進むための初期化 ---
        function initGameForNextLevel() {
            currentLevel++;
            player.hp += (player.hp * 0.5);
            if (player.hp > player.maxHp) {
                player.hp = player.maxHp;
            }
            player.hp = Math.round(player.hp);
            resetGameElements();
            startScreen.classList.remove('active');
            gameOverScreen.classList.remove('active');
            victoryScreen.classList.remove('active');
            currentState = GAME_STATE.IDLE;
        }

        // --- ゲーム要素のリセット ---
        function resetGameElements() {
            enemies = [];
            attackTargets = [];
            slashEffects = [];
            timeStopEffectAlpha = 0;
            timeStopTimer = 0;
            cutsceneTimer = 0;
            player.x = CANVAS_WIDTH / 2;
            player.y = CANVAS_HEIGHT / 2;

            const ENEMY_COUNT = baseEnemyCount + (currentLevel - 1) * 2;
            for (let i = 0; i < ENEMY_COUNT; i++) {
                enemies.push({
                    x: Math.random() * (CANVAS_WIDTH - ENEMY_SIZE * 2) + ENEMY_SIZE,
                    y: Math.random() * (CANVAS_HEIGHT - ENEMY_SIZE * 2) + ENEMY_SIZE,
                    size: ENEMY_SIZE,
                    color: ENEMY_COLOR,
                    hp: 1,
                    isHit: false,
                    hitStunTimer: 0, 
                    velocityX: 0,
                    velocityY: 0,
                    moveTimer: Math.random() * 100 + 50,
                    attackCooldown: Math.random() * 300 + 200,
                    isDashing: false,
                    splitAngle: Math.random() * Math.PI,
                    splitApart: 0
                });
            }
        }

        // --- ゲーム開始 (Startボタンが押された時) ---
        function startGame() {
            currentLevel = 1;
            player.hp = player.maxHp;
            ultimateGauge = 0;
            resetGameElements(); 
            startScreen.classList.remove('active');
            currentState = GAME_STATE.IDLE;
            setBodyBackground('normal');
        }

        // --- 必殺技発動処理 ---
        function triggerUltimate() {
            if (currentState === GAME_STATE.IDLE && ultimateGauge >= maxUltimateGauge) {
                currentState = GAME_STATE.ULT_CUTSCENE;
                cutsceneTimer = cutsceneDuration;
                timeStopEffectAlpha = 1; 
                attackTargets = []; 
                ultimateGauge = 0;
                setBodyBackground('hissatsu'); 
            }
        }

        // --- 必殺技終了処理 ---
        function endAimingPhase() {
            if (currentState !== GAME_STATE.AIMING) return;
            setBodyBackground('normal'); 
            if (attackTargets.length > 0) {
                currentState = GAME_STATE.ATTACKING; 
                timeStopEffectAlpha = 0; 
                attackTargets.forEach(target => {
                    const enemy = enemies[target.enemyIndex];
                    if (enemy && !enemy.isHit) {
                        enemy.isHit = true; 
                        enemy.hp = 0;
                        enemy.splitAngle = Math.atan2(target.y - player.y, target.x - player.x) + Math.PI / 2;
                        enemy.splitApart = 1;
                    }
                });
                setTimeout(() => {
                    if (currentState !== GAME_STATE.GAMEOVER) {
                         currentState = GAME_STATE.IDLE;
                    }
                }, 100); 
            } else {
                currentState = GAME_STATE.IDLE;
                timeStopEffectAlpha = 0;
            }
            timeStopTimer = 0;
        }

        // --- ゲームロジック更新 ---
        function update() {
            if (currentState === GAME_STATE.MENU || 
                currentState === GAME_STATE.GAMEOVER || 
                currentState === GAME_STATE.FINISHED) {
                return;
            }

            if (currentState === GAME_STATE.ULT_CUTSCENE) {
                cutsceneTimer--;
                if (cutsceneTimer <= 0) {
                    currentState = GAME_STATE.AIMING;
                    timeStopTimer = timeStopDuration;
                }
                return;
            }
            
            if (currentState === GAME_STATE.IDLE && ultimateGauge < maxUltimateGauge) {
                ultimateGauge++;
            }

            if (currentState === GAME_STATE.AIMING) {
                timeStopTimer--;
                if (timeStopTimer <= 0) {
                    endAimingPhase();
                }
            }

            if (currentState === GAME_STATE.IDLE) {
                updateEnemies();
            }

            enemies.forEach(enemy => {
                if (enemy.isHit && enemy.splitApart < enemy.size * 3) {
                    enemy.splitApart += 1;
                }
            });

            updateSlashEffects();

            if (player.hp <= 0) {
                currentState = GAME_STATE.GAMEOVER;
                gameOverScreen.classList.add('active');
                gameOverLevelDisplay.textContent = `到達レベル: ${currentLevel}`;
                setBodyBackground('normal');
            }

            if (currentState === GAME_STATE.IDLE) {
                const allEnemiesHit = enemies.every(e => e.isHit);
                if (enemies.length > 0 && allEnemiesHit) {
                    currentState = GAME_STATE.FINISHED;
                    victoryScreen.classList.add('active');
                    currentLevelDisplay.textContent = `現在のレベル: ${currentLevel}`;
                }
            }
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                if (enemy.isHit) return; 

                if (enemy.hitStunTimer > 0) {
                    enemy.hitStunTimer--;
                    return; 
                }
                
                if (!enemy.isDashing) {
                    enemy.attackCooldown--;
                    if (enemy.attackCooldown <= 0) {
                        enemy.isDashing = true;
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        const dashSpeed = 5;
                        enemy.velocityX = Math.cos(angle) * dashSpeed;
                        enemy.velocityY = Math.sin(angle) * dashSpeed;
                    }
                }
                if (!enemy.isDashing) {
                    enemy.moveTimer--;
                    if (enemy.moveTimer <= 0) {
                        const moveSpeed = 0.5; 
                        const angle = Math.random() * Math.PI * 2;
                        enemy.velocityX = Math.cos(angle) * moveSpeed;
                        enemy.velocityY = Math.sin(angle) * moveSpeed;
                        enemy.moveTimer = Math.random() * 100 + 50;
                    }
                }
                enemy.x += enemy.velocityX;
                enemy.y += enemy.velocityY;
                if (enemy.x < enemy.size || enemy.x > CANVAS_WIDTH - enemy.size) {
                    enemy.velocityX *= -1;
                    if (enemy.isDashing) {
                        enemy.isDashing = false;
                        enemy.attackCooldown = Math.random() * 300 + 200;
                    }
                }
                if (enemy.y < enemy.size || enemy.y > CANVAS_HEIGHT - enemy.size) {
                    enemy.velocityY *= -1;
                    if (enemy.isDashing) {
                        enemy.isDashing = false;
                        enemy.attackCooldown = Math.random() * 300 + 200;
                    }
                }
                if (enemy.isDashing) {
                    const dist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);
                    if (dist < player.size / 2 + enemy.size) {
                        player.hp -= 5; 
                        enemy.isDashing = false;
                        enemy.attackCooldown = Math.random() * 300 + 200;
                        enemy.velocityX *= -1; 
                        enemy.velocityY *= -1;
                    }
                }
            });
        }

        function updateSlashEffects() {
            for (let i = slashEffects.length - 1; i >= 0; i--) {
                slashEffects[i].lifetime--;
                if (slashEffects[i].lifetime <= 0) {
                    slashEffects.splice(i, 1);
                }
            }
        }

        // --- 描画関数 ---
        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (currentState === GAME_STATE.MENU) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // 敵
            enemies.forEach(enemy => {
                if (enemy.isHit) {
                    drawSplitEnemy(enemy);
                } else {
                    ctx.fillStyle = enemy.hitStunTimer > 0 ? '#aaa' : (enemy.isDashing ? ENEMY_DASH_COLOR : enemy.color);
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // プレイヤー
            if (playerImage.complete && playerImage.naturalWidth > 0) {
                ctx.drawImage(playerImage, player.x - player.size, player.y - player.size, player.size * 2, player.size * 2);
            } else {
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x - player.size / 2, player.y - player.size / 2, player.size, player.size);
            }

            // 斬撃ターゲット
            if (currentState === GAME_STATE.AIMING) {
                attackTargets.forEach(target => {
                    ctx.strokeStyle = 'cyan';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(target.x, target.y, ENEMY_SIZE + 5, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }

            // 時間停止エフェクト
            if (timeStopEffectAlpha > 0) {
                const imageData = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    data[i] = avg + (data[i] - avg) * (1 - timeStopFilterStrength * timeStopEffectAlpha);
                    data[i + 1] = avg + (data[i + 1] - avg) * (1 - timeStopFilterStrength * timeStopEffectAlpha);
                    data[i + 2] = avg + (data[i + 2] - avg) * (1 - timeStopFilterStrength * timeStopEffectAlpha);
                }
                ctx.putImageData(imageData, 0, 0);
                
                ctx.fillStyle = `rgba(0, 0, 0, ${0.3 * timeStopEffectAlpha})`;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                if (currentState !== GAME_STATE.ULT_CUTSCENE && playerImage.complete && playerImage.naturalWidth > 0) {
                    ctx.save();
                    ctx.filter = 'brightness(1.5) contrast(1.2)'; 
                    ctx.drawImage(playerImage, player.x - player.size, player.y - player.size, player.size * 2, player.size * 2);
                    ctx.restore(); 
                }
            }

            // 必殺技カットイン
            if (currentState === GAME_STATE.ULT_CUTSCENE) {
                if (hissatsuImage.complete && hissatsuImage.naturalWidth > 0) {
                    const imgRatio = hissatsuImage.naturalWidth / hissatsuImage.naturalHeight;
                    const canvasRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
                    let drawWidth, drawHeight, drawX, drawY;

                    if (imgRatio > canvasRatio) {
                        drawHeight = CANVAS_HEIGHT;
                        drawWidth = drawHeight * imgRatio;
                        drawX = (CANVAS_WIDTH - drawWidth) / 2;
                        drawY = 0;
                    } else {
                        drawWidth = CANVAS_WIDTH;
                        drawHeight = drawWidth / imgRatio;
                        drawX = 0;
                        drawY = (CANVAS_HEIGHT - drawHeight) / 2;
                    }
                    
                    ctx.save();
                    ctx.filter = 'brightness(1.5)';
                    ctx.drawImage(hissatsuImage, drawX, drawY, drawWidth, drawHeight);
                    ctx.restore();
                }
            }
            
            // リアルタイム斬撃
            drawSlashEffects();

            // UI
            if (currentState !== GAME_STATE.GAMEOVER && currentState !== GAME_STATE.FINISHED) {
                drawUI();
            }

            requestAnimationFrame(gameLoop);
        }

        function drawSplitEnemy(enemy) {
            const angle = enemy.splitAngle;
            const dx1 = Math.cos(angle) * enemy.splitApart;
            const dy1 = Math.sin(angle) * enemy.splitApart;
            const dx2 = -dx1;
            const dy2 = -dy1;
            ctx.fillStyle = ENEMY_HIT_COLOR;
            ctx.beginPath();
            ctx.arc(enemy.x + dx1, enemy.y + dy1, enemy.size, angle - Math.PI / 2, angle + Math.PI / 2);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.arc(enemy.x + dx2, enemy.y + dy2, enemy.size, angle + Math.PI / 2, angle - Math.PI / 2);
            ctx.closePath();
            ctx.fill();
        }

        function drawSlashEffects() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            slashEffects.forEach(effect => {
                const slashLength = effect.size * 1.5;
                ctx.save();
                ctx.translate(effect.x, effect.y);
                ctx.rotate(effect.angle);
                ctx.beginPath();
                ctx.moveTo(-slashLength / 2, -slashLength / 2);
                ctx.lineTo(slashLength / 2, slashLength / 2);
                ctx.stroke();
                ctx.restore();
            });
        }

        function drawUI() {
            const barWidth = 220;
            const hpBarHeight = 24;
            const ultBarHeight = 18;
            const x = CANVAS_WIDTH / 2 - barWidth / 2;
            const hpY = CANVAS_HEIGHT - 50; 
            const ultY = hpY - ultBarHeight - 10; 

            // Ultimate gauge background
            ctx.fillStyle = 'rgba(20, 20, 30, 0.8)'; 
            ctx.fillRect(x - 2, ultY - 2, barWidth + 4, ultBarHeight + 4);
            
            ctx.fillStyle = '#1a1a2e'; 
            ctx.fillRect(x, ultY, barWidth, ultBarHeight);
            
            const currentUltWidth = (ultimateGauge / maxUltimateGauge) * barWidth;
            const isReady = ultimateGauge >= maxUltimateGauge;
            
            // Ultimate gauge fill with gradient
            const ultGradient = ctx.createLinearGradient(x, ultY, x + barWidth, ultY);
            if (isReady) {
                ultGradient.addColorStop(0, '#00ffff');
                ultGradient.addColorStop(1, '#00ccff');
            } else {
                ultGradient.addColorStop(0, '#0066ff');
                ultGradient.addColorStop(1, '#0099ff');
            }
            ctx.fillStyle = ultGradient;
            ctx.fillRect(x, ultY, currentUltWidth, ultBarHeight);
            
            // Ultimate gauge border
            ctx.strokeStyle = isReady ? '#00ffff' : 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, ultY, barWidth, ultBarHeight);
            
            // Ultimate gauge glow effect when ready
            if (isReady) {
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.strokeRect(x, ultY, barWidth, ultBarHeight);
                ctx.shadowBlur = 0;
            }
            
            // Ultimate text
            ctx.fillStyle = isReady ? '#00ffff' : 'white';
            ctx.font = 'bold 13px "Hina Mincho", serif';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 4;
            const ultText = (currentState === GAME_STATE.AIMING || currentState === GAME_STATE.ULT_CUTSCENE) ? "神速発動中..." : (isReady ? "必殺技 READY!" : "必殺技");
            ctx.fillText(ultText, CANVAS_WIDTH / 2, ultY + ultBarHeight / 2 + 5);
            ctx.shadowBlur = 0;

            // HP bar background
            ctx.fillStyle = 'rgba(20, 20, 30, 0.8)';
            ctx.fillRect(x - 2, hpY - 2, barWidth + 4, hpBarHeight + 4);
            
            ctx.fillStyle = '#2a1a1a';
            ctx.fillRect(x, hpY, barWidth, hpBarHeight);
            
            const currentHpWidth = (player.hp / player.maxHp) * barWidth;
            
            // HP bar fill with gradient
            const hpGradient = ctx.createLinearGradient(x, hpY, x + barWidth, hpY);
            if (player.hp < 30) {
                hpGradient.addColorStop(0, '#ff3333');
                hpGradient.addColorStop(1, '#ff6666');
            } else {
                hpGradient.addColorStop(0, '#33cc33');
                hpGradient.addColorStop(1, '#66ff66');
            }
            ctx.fillStyle = hpGradient;
            ctx.fillRect(x, hpY, currentHpWidth > 0 ? currentHpWidth : 0, hpBarHeight);
            
            // HP bar border
            ctx.strokeStyle = player.hp < 30 ? '#ff4444' : 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, hpY, barWidth, hpBarHeight);
            
            // HP text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px "Hina Mincho", serif';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 4;
            ctx.fillText(`HP: ${Math.max(0, Math.round(player.hp))} / ${player.maxHp}`, CANVAS_WIDTH / 2, hpY + hpBarHeight / 2 + 5);
            ctx.shadowBlur = 0;

            // Time stop countdown
            if (currentState === GAME_STATE.AIMING && timeStopTimer > 0) {
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 36px "Hina Mincho", serif';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 20;
                const secondsLeft = (timeStopTimer / 60).toFixed(1);
                ctx.fillText(secondsLeft, CANVAS_WIDTH / 2, 60);
                ctx.shadowBlur = 0;
            }

            // Ultimate button display control
            if (currentState === GAME_STATE.IDLE && ultimateGauge >= maxUltimateGauge) {
                ultimateButton.className = 'game-button ready';
                ultimateButton.textContent = '必殺';
            } else if (currentState === GAME_STATE.AIMING) {
                ultimateButton.className = 'game-button aiming';
                ultimateButton.textContent = '発動';
            } else {
                ultimateButton.className = 'game-button'; 
                ultimateButton.textContent = '';
            }
        }

        // 画面リサイズ関数
        function resizeGame() {
            const marginPercentage = 0.85;
            const screenWidth = window.innerWidth * marginPercentage;
            const screenHeight = window.innerHeight * marginPercentage;
            const gameWidth = 960;
            const gameHeight = 540;

            const scale = Math.min(screenWidth / gameWidth, screenHeight / gameHeight);
            
            gameScale = scale; 

            gameContainer.style.transform = `scale(${scale})`;
            
            gameContainer.style.left = `${(window.innerWidth - (gameWidth * scale)) / 2}px`;
            gameContainer.style.top = `${(window.innerHeight - (gameHeight * scale)) / 2}px`;
        }

        // --- イベントリスナー ---
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', initGame);
        nextLevelButton.addEventListener('click', initGameForNextLevel); 

        // 必殺技ボタン
        ultimateButton.addEventListener('click', () => {
            if (currentState === GAME_STATE.IDLE) {
                triggerUltimate();
            } else if (currentState === GAME_STATE.AIMING) {
                endAimingPhase();
            }
        });

        // キーボード
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault(); 
                triggerUltimate();
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && currentState === GAME_STATE.AIMING) {
                endAimingPhase();
            }
        });

        // クリック座標の計算
        canvas.addEventListener('click', (e) => {
            e.preventDefault(); 
            const rect = canvas.getBoundingClientRect();
            
            const mouseX = (e.clientX - rect.left) / gameScale;
            const mouseY = (e.clientY - rect.top) / gameScale;

            if (currentState === GAME_STATE.ULT_CUTSCENE) return;

            if (currentState === GAME_STATE.AIMING) {
                enemies.forEach((enemy, index) => {
                    const dist = Math.sqrt((mouseX - enemy.x)**2 + (mouseY - enemy.y)**2);
                    if (dist < enemy.size && !enemy.isHit) { 
                        const isAlreadyTargeted = attackTargets.some(t => t.enemyIndex === index);
                        if (!isAlreadyTargeted) {
                            attackTargets.push({ x: enemy.x, y: enemy.y, enemyIndex: index });
                        }
                    }
                });
            } 
            else if (currentState === GAME_STATE.IDLE) {
                enemies.forEach((enemy) => {
                    if (enemy.isHit) return; 
                    const dist = Math.sqrt((mouseX - enemy.x)**2 + (mouseY - enemy.y)**2); 
                    if (dist < enemy.size && enemy.hitStunTimer <= 0) {
                        enemy.hp -= 1;
                        enemy.hitStunTimer = hitStunDuration; 
                        slashEffects.push({
                            x: enemy.x,
                            y: enemy.y,
                            size: enemy.size,
                            angle: Math.random() * Math.PI, 
                            lifetime: 10 
                        });
                        if (enemy.hp <= 0) {
                            enemy.isHit = true;
                            enemy.splitAngle = Math.random() * Math.PI;
                            enemy.splitApart = 1;
                        }
                    }
                });
            }
        });

        // --- ゲームループ ---
        function gameLoop() {
            update();
            draw();
        }

        // --- ゲーム開始処理 ---
        window.addEventListener('resize', resizeGame); 
        initGame();
        gameLoop();
        resizeGame(); 
        
    </script>
</body>
</html>
